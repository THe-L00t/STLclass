//-------------------------------------------
// STRING.h - STL의 동작을 이해하기 위한 class / std::string과 유사하게 작성
//
//	2025. 04. 10 - 시작
//-------------------------------------------

#include "STRING.h"

size_t STRING::gid{ 0 };

STRING::STRING()
	:id{ gid++ }
{
	std::println("[{:6}] - {:16} 자원수 : {:3}, 주소 : {:12} 자원의 주소 : {:12}", id, "디폴트생성자", s, (void*)this, (void*)d.get());
}
STRING::~STRING()
{
	std::println("[{:6}] - {:16}", id, "소멸자");
}
STRING::STRING(const char* p)
	: s{ strlen(p) }, d{ std::make_unique<char[]>(s) }, id{ gid++ } {
	//d.release();   디폴트 초기화시 상관 없음
	memcpy(d.get(), p, s);		//DMA 가 가능하다. 
	std::println("[{:6}] - {:16} 자원수 : {:3}, 주소 : {:12} 자원의 주소 : {:16}", id, "생성자", s, (void*)this,(void*)d.get());
}

STRING::STRING(const STRING& other) 
	: s{ other.s } {
	*this = other;
	/*d = std::make_unique<char[]>(s);
	memcpy(d.get(), other.d.get(), s);*/
	std::println("[{:6}] - {:16} 자원수 : {:3}, 주소 : {:12} 자원의 주소 : {:12}", id, "복사생성자", s, (void*)this, (void*)d.get());
}

STRING& STRING::operator=(const STRING& other) {
	if (this == &other)		//& addressof
		return *this;
	d.release();
	s = other.size();
	d = std::make_unique<char[]>(s);
	memcpy(d.get(), other.d.get(), s);
	id = gid++;
	std::println("[{:6}] - {:16} 자원수 : {:3}, 주소 : {:12} 자원의 주소 : {:12}", id, "복사할당연산자", s, (void*)this, (void*)d.get());
	return *this;
}

bool STRING::operator<(const STRING& other)
{
	return this->s < other.s;
}

size_t STRING::size() const {
	return s;
}

 std::ostream& operator<<(std::ostream& os, const STRING& str) {
	return os << str.d.get();
}